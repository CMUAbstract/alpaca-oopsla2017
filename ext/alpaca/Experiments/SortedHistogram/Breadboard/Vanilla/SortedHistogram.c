#include <stdlib.h>
#include <limits.h>

#include <msp430.h>
#include "data_bins.h"
#include "data_thresholds.h"

#define NUM_ITERS 100
#define SAMPLES_PER_ITER 20
#define NUM_BINS 10 /*total number of bins*/
#define SAMPLE_MAX 100 /*max expected value of a sample*/
#undef USE_LEDS
#undef FLASH_ON_BOOT

/*Need to calibrate to get real values for this*/
const unsigned thresholds[NUM_BINS] = {
  10, 20, 30, 40, 50, 60, 70, 80, 90, 0xffff /*last bin is for everything else*/
};

/* These "pinned" variables are fixed at these addresses. */

/*currTemp is a pointer to the current entry in the data log*/
volatile __attribute__((section("FRAMVARS"))) unsigned int inErrorState;
volatile __attribute__((section("FRAMVARS"))) unsigned int initialized;
volatile __attribute__((section("FRAMVARS"))) unsigned int finished;
volatile __attribute__((section("FRAMVARS"))) unsigned int reboots;
volatile __attribute__((section("FRAMVARS"))) unsigned int numSamples;
volatile __attribute__((section("FRAMVARS"))) unsigned int numSwaps;


/*dataLog is a buffer of TEMP_WINDOW NV data entries*/
/*defined in data_array.h, generated by dinoArrayGen.pl... ugh*/
unsigned getOneSample(){

  unsigned ret = rand() % SAMPLE_MAX;
  return ret;
   
}

void abortWithError(){
  
  inErrorState = 0xBEEE;  

#if defined(WISP5)
  P4OUT |= BIT0;
#elif defined(BREADBOARD)
  P1OUT |= BIT0;
#endif //BREADBOARD

  while(1){ }

}
 
/*We will use __NV_dataBin[] as a list of bins, each of which corresponds
  to a dataerature range.

  We will use __NV_dataThresh[] as a list of thresholds, each of which 
  is the upper bound of the data value in the corresponding dataBin bin

  NUM_BINS = 3
  thresholds [ 10 | 20 | 30 ]
  datathresh [  0 |  1 |  2 ] 
  databins   [  0 |  0 |  0 ]
 
  addToBin(15)
  
  thresholds [ 10 | 20 | 30 ]
  datathresh [  0 |  1 |  2 ] 
  databins   [  0 |  1 |  0 ]

  swapBins(0,1)
  
  thresholds [ 10 | 20 | 30 ]
  datathresh [  1 |  0 |  2 ] <--entry 0 contains "1", a pointer to "20"
  databins   [  1 |  0 |  0 ] <--entry 0 contains "1", the count for "20"


  and so on.


  Invariant: datas that contribute to the value in __NV_dataBin[i]
             were less than __NV_dataBin[i] when they were recorded.
  
             each entry in thresholds occurs in exactly one location in
             __NV_dataThresh[].

*/
void addToBin(unsigned data){

  /*Fill this out so we pass a value in and get a bin back*/
  unsigned i;
  unsigned thresh = 0xffff;
  for( i = 0; i < NUM_BINS; i++){

    /*Look through the sorted list of histogram thresholds...*/
    if( data < thresholds[i] ){

      /*thresholds[i] is the threshold for this measurment*/
      thresh = thresholds[i];
      break;

    }

  } 

  unsigned j; 
  /*Find this threshold in the unsorted list of histogram keys*/
  for( j = 0; j < NUM_BINS; j++ ){

    unsigned tInd = __histo_read__NV_dataThresh(j);//the index for this key 
    unsigned t = thresholds[tInd];//the key itself

    /*This key (t) matches the threshold 
      for this measurement (thresholds[i]).*/
    if( t == thresh ){

      /*Increment the found key's bin's value*/
      unsigned binVal = __histo_read__NV_dataBin(j);
      __histo_write__NV_dataBin(j, binVal+1);

      return;

    }

  }

  /*If we get here, the measurement has no bin in
    the histogram, which is an error*/
  abortWithError();

}

void swapBins(int binI, int binJ){

  if(binI >= NUM_BINS ||
     binJ >= NUM_BINS ){
    return;
  }
  numSwaps++;
  unsigned tmpBinVal = __histo_read__NV_dataBin(binI);
  unsigned tmpThrVal = __histo_read__NV_dataThresh(binI);
  
  __histo_write__NV_dataThresh(binI, __histo_read__NV_dataThresh(binJ)); 
  __histo_write__NV_dataBin(binI, __histo_read__NV_dataBin(binJ)); 
  /*A failure here leaves the data structure corrupted!*/
  __histo_write__NV_dataBin(binJ, tmpBinVal); 
  __histo_write__NV_dataThresh(binJ, tmpThrVal); 
   
}

void sortBinsByFrequency(void){

  unsigned i = 0;
  for( i = 1; i < NUM_BINS; i++ ){

    unsigned j = i;     
    while( j > 0 && __histo_read__NV_dataBin(j - 1) >
                    __histo_read__NV_dataBin(j) ) {
  
        swapBins(j,j-1);
        j--;
  
    }

  }

}  


void checkInvariants(void){

  unsigned i;
  unsigned numKeysFound = 0;
  unsigned keysFound[NUM_BINS];
  for( i = 0; i < NUM_BINS; i++ ){
    keysFound[i] = 0;
  }
  for( i = 0; i < NUM_BINS; i++ ){

    unsigned key = __histo_read__NV_dataThresh(i);

    if( keysFound[key] == 0 ){

      keysFound[key] = 1;
      numKeysFound++;
          
    }else{
      abortWithError();
    }

  }


  if( numKeysFound < NUM_BINS ){
      abortWithError();
  }

}


void initializeHardware(){
  
#ifdef WISP5
  setupDflt_IO();

  PRXEOUT |= PIN_RX_EN; /** TODO: enable PIN_RX_EN only when needed in the future */

  /*Before anything else, do the device hardware configuration*/
  P4DIR |= BIT0;
  PJDIR |= BIT6;
#if defined(USE_LEDS) && defined(FLASH_ON_BOOT)
  P4OUT |= BIT0;
  PJOUT |= BIT6;
  int i;
  for (i = 0; i < 0xffff; i++)
    ;
  P4OUT &= ~BIT0;  // Toggle P4.4 using exclusive-OR
  PJOUT &= ~BIT6;  // Toggle P4.5 using exclusive-OR
#endif /*USE LEDS*/
#endif /*WISP5*/

#ifdef BREADBOARD
  P1DIR |= BIT0;
  P4DIR |= BIT4;// Set P4.4/5 to output direction
  P1OUT &= ~BIT0;  
  P4OUT &= ~BIT4;  
#if defined(USE_LEDS) && defined(FLASH_ON_BOOT)
  P1OUT |= BIT0;
  P4OUT |= BIT4;
  int i;
  for (i = 0; i < 0xffff; i++)
    ;
  P1OUT &= ~BIT0;  
  P4OUT &= ~BIT4;  
#endif //USE LEDS

#endif /*BREADBOARD*/

}



void initializeNVData() {
  if(initialized != 0xBEEE){
    for(int i = 0; i < NUM_BINS; i++){
      __histo_write__NV_dataBin(i,0x0);
      /*The bin corresponding to the ith 
        threshold is in the ith position to start*/
      __histo_write__NV_dataThresh(i,i);
      
    }
    reboots = 0;
    numSamples = 0;
    numSwaps = 0;
    initialized = 0xBEEE;
  }
}

__attribute__((section(".init9"), aligned(2)))
int main(void){

  WDTCTL = WDTPW | WDTHOLD;  // Stop watchdog timer
  PM5CTL0 &= ~LOCKLPM5;
  initializeHardware();

  if( finished == 0xBEEE ){
#if defined(WISP5)
    PJOUT |= BIT6;
#elif defined(BREADBOARD)
    P4OUT |= BIT4;
#endif
    while( 1 ){ }
  }

  if( inErrorState == 0xBEEE ){

    abortWithError();

  }

  initializeNVData();

  reboots++;

  while( numSamples < (NUM_ITERS * SAMPLES_PER_ITER) ){

    int r;
    for(r = 0; r < SAMPLES_PER_ITER; r++){

      unsigned samp = getOneSample();
      addToBin(samp);
      numSamples++;

    }

    sortBinsByFrequency();
    checkInvariants();

  }


  finished = 0xBEEE;
#if defined(WISP5)
  PJOUT |= BIT6;
#elif defined(BREADBOARD)
  P4OUT |= BIT4;
#endif
  while( 1 ){ }

}
