#include <stdlib.h>
#include <limits.h>

#ifndef LAPTOP
#include <msp430.h>
#include "temp_bins.h"
#include "temp_thresholds.h"
#include "adc_sensor.h"
#else
#include <stdio.h>
#include <assert.h>
#include <time.h>
#endif

#define NUM_BINS 10 /*total number of bins*/
#define USE_LEDS
#define FLASH_ON_BOOT

/*Need to calibrate to get real values for this*/
const unsigned thresholds[NUM_BINS] = {
  10, 20, 30, 40, 50, 60, 70, 80, 90, 0xffff /*last bin is for everything else*/
};

/* These "pinned" variables are fixed at these addresses. */

/*currTemp is a pointer to the current entry in the temp log*/
#ifndef LAPTOP
volatile __attribute__((section("FRAMVARS"))) unsigned int __NV_totalSamples;
volatile __attribute__((section("FRAMVARS"))) unsigned int inErrorState;
volatile __attribute__((section("FRAMVARS"))) unsigned int uninitialized;
#else
volatile unsigned int __NV_totalSamples;
volatile unsigned int inErrorState;
static unsigned tempBins[NUM_BINS];
static unsigned tempThresh[NUM_BINS];

unsigned __dino_read__NV_tempBin(unsigned i){
  return tempBins[i];
}

void __dino_write__NV_tempBin(unsigned i, unsigned v){
  tempBins[i] = v;
}

unsigned __dino_read__NV_tempThresh(unsigned i){
  return tempThresh[i];
}

void __dino_write__NV_tempThresh(unsigned i, unsigned v){
  tempThresh[i] = v;
}
#endif


/*tempLog is a buffer of TEMP_WINDOW NV data entries*/
/*defined in temp_array.h, generated by dinoArrayGen.pl... ugh*/
#ifndef LAPTOP
unsigned getOneSample(){

  //Read thermometer here
  unsigned ret = adc12_sample();
  return ret;
   
}
#endif

void abortWithError(){
  
  inErrorState = 1;  
  while(1){
#ifndef LAPTOP
#if defined(WISP5)
    P4OUT |= BIT0;
    PJOUT |= BIT6;
#elif defined(BREADBOARD)
    P1OUT |= BIT0;
#endif //BREADBOARD
    int i;
    for (i = 0; i < 0xfff; i++) ;
#if defined(WISP5)
    P4OUT &= ~BIT0;  // Toggle P4.4 using exclusive-OR
    PJOUT &= ~BIT6;  // Toggle P4.5 using exclusive-OR
#elif defined(BREADBOARD)
    P1OUT &= ~BIT0;
#endif //BREADBOARD

#endif //Laptop
  }

}
 
#ifdef LAPTOP 
void printHisto(){
  int q;
  fprintf(stderr,"<");
  for( q = 0; q < NUM_BINS; q++ ){
    fprintf(stderr,"(%u, %u)",__dino_read__NV_tempThresh(q),__dino_read__NV_tempBin(q));
  }
  fprintf(stderr,">\n");
}
#endif
/*We will use __NV_tempBin[] as a list of bins, each of which corresponds
  to a temperature range.

  We will use __NV_tempThresh[] as a list of thresholds, each of which 
  is the upper bound of the data value in the corresponding tempBin bin

  NUM_BINS = 3
  thresholds [ 10 | 20 | 30 ]
  tempthresh [  0 |  1 |  2 ] 
  tempbins   [  0 |  0 |  0 ]
 
  addToBin(15)
  
  thresholds [ 10 | 20 | 30 ]
  tempthresh [  0 |  1 |  2 ] 
  tempbins   [  0 |  1 |  0 ]

  swapBins(0,1)
  
  thresholds [ 10 | 20 | 30 ]
  tempthresh [  1 |  0 |  2 ] <--entry 0 contains "1", a pointer to "20"
  tempbins   [  1 |  0 |  0 ] <--entry 0 contains "1", the count for "20"


  and so on.


  Invariant: temps that contribute to the value in __NV_tempBin[i]
             were less than __NV_tempBin[i] when they were recorded.
  
             each entry in thresholds occurs in exactly one location in
             __NV_tempThresh[].

             the sum of values in __NV_tempBin[] is exactly equal to
             __NV_totalSamples
*/
void addToBin(unsigned temp){

  /*Fill this out so we pass a value in and get a bin back*/
  unsigned i;
  unsigned thresh = 0xffff;
  #ifdef LAPTOP
  fprintf(stderr,"Adding %u\n",temp);
  #endif
  for( i = 0; i < NUM_BINS; i++){

    /*Look through the sorted list of histogram thresholds...*/
    if( temp < thresholds[i] ){

      /*thresholds[i] is the threshold for this measurment*/
      thresh = thresholds[i];
      #ifdef LAPTOP
      fprintf(stderr,"temp %u is less than %u\n",temp,thresh);
      #endif
      break;

    }

  } 

  unsigned j; 
  /*Find this threshold in the unsorted list of histogram keys*/
  for( j = 0; j < NUM_BINS; j++ ){

    unsigned tInd = __dino_read__NV_tempThresh(j);//the index for this key 
    unsigned t = thresholds[tInd];//the key itself

    /*This key (t) matches the threshold 
      for this measurement (thresholds[i]).*/
    if( t == thresh ){
    #ifdef LAPTOP
    fprintf(stderr,"key %u is %u, matching %u, binning %u \n",j,t,thresh,temp);
    #endif

      /*Increment the found key's bin's value*/
      unsigned binVal = __dino_read__NV_tempBin(j);
      __dino_write__NV_tempBin(j, binVal+1);

      return;

    }

  }

  /*If we get here, the measurement has no bin in
    the histogram, which is an error*/
#ifndef LAPTOP
  abortWithError();
#else
  assert(0 && "NO BIN FOR MEASUREMENT");
#endif

}

void swapBins(int binI, int binJ){

  if(binI >= NUM_BINS ||
     binJ >= NUM_BINS ){
    return;
  }

  unsigned tmpBinVal = __dino_read__NV_tempBin(binI);
  unsigned tmpThrVal = __dino_read__NV_tempThresh(binI);
  
  __dino_write__NV_tempBin(binI, __dino_read__NV_tempBin(binJ)); 
  __dino_write__NV_tempThresh(binI, __dino_read__NV_tempThresh(binJ)); 
  /*A failure here leaves the data structure corrupted!*/
  __dino_write__NV_tempBin(binJ, tmpBinVal); 
  __dino_write__NV_tempThresh(binJ, tmpThrVal); 
   
}

void sortBinsByFrequency(void){
  /*InsertionSort: http://en.wikipedia.org/wiki/Insertion_sort*/
  unsigned i = 0;
  for( i = 1; i < NUM_BINS; i++ ){
   
    unsigned j = i;

    while( j > 0 && 
           __dino_read__NV_tempBin(j-1) > 
           __dino_read__NV_tempBin(j) ){

      swapBins(j,j-1);

    }

  }

}  


void checkInvariants(void){

  unsigned i;
  unsigned total = 0;
  unsigned numKeysFound = 0;
  unsigned keysFound[NUM_BINS];
  for( i = 0; i < NUM_BINS; i++ ){
    keysFound[i] = 0;
  }
  for( i = 0; i < NUM_BINS; i++ ){

    total += __dino_read__NV_tempBin(i); 
    unsigned key = __dino_read__NV_tempThresh(i);

    if( keysFound[key] == 0 ){

      keysFound[key] = 1;
      numKeysFound++;
          
    }else{
#ifndef LAPTOP
      abortWithError();
#else
      assert(0 && "Duplicate Key Found!");
#endif
    }

  }


#ifndef LAPTOP
  if( total != __NV_totalSamples ||
      numKeysFound < NUM_BINS ){
      abortWithError();
  }
#else
  assert(total == __NV_totalSamples);
  assert(numKeysFound == NUM_BINS);
#endif

}


void initializeHardware(){
  
#ifndef LAPTOP
#ifdef WISP
  setupDflt_IO();

  PRXEOUT |= PIN_RX_EN; /** TODO: enable PIN_RX_EN only when needed in the future */

  // set clock speed to 4 MHz
  CSCTL0_H = 0xA5;
  CSCTL1 = DCOFSEL0 | DCOFSEL1;
  CSCTL2 = SELA_0 | SELS_3 | SELM_3;
  CSCTL3 = DIVA_0 | DIVS_0 | DIVM_0;

  /*Before anything else, do the device hardware configuration*/
  P4DIR |= BIT0;
  PJDIR |= BIT6;
#if defined(USE_LEDS) && defined(FLASH_ON_BOOT)
  P4OUT |= BIT0;
  PJOUT |= BIT6;
  int i;
  for (i = 0; i < 0xffff; i++)
    ;
  P4OUT &= ~BIT0;  // Toggle P4.4 using exclusive-OR
  PJOUT &= ~BIT6;  // Toggle P4.5 using exclusive-OR
#endif

#ifdef BREADBOARD
  P1DIR |= BIT0;
  P1OUT |= BIT0;
#if defined(USE_LEDS) && defined(FLASH_ON_BOOT)
  P1OUT |= BIT0;
  int i;
  for (i = 0; i < 0xffff; i++)
    ;
  P1OUT &= ~BIT0;  
#endif
#endif

#endif

#else
  fprintf(stderr,"Starting Histogram Test\n");
#endif//LAPTOP
}



void initializeNVData() {
#ifndef LAPTOP
  if( uninitialized == 0 ){
#endif
    for(int i = 0; i < NUM_BINS; i++){
      __dino_write__NV_tempBin(i,0x0);
      /*The bin corresponding to the ith 
        threshold is in the ith position to start*/
      __dino_write__NV_tempThresh(i,i);
      
    }
    __NV_totalSamples = 0;
    uninitialized = 1;
#ifndef LAPTOP
  }
#endif
}

#ifndef LAPTOP
__attribute__((section(".init9"), aligned(2)))
#endif
int main(void){

#ifndef LAPTOP
  WDTCTL = WDTPW | WDTHOLD;  // Stop watchdog timer
  PM5CTL0 &= ~LOCKLPM5;
#endif
  initializeHardware();
  initializeNVData();
  if( inErrorState == 1 ){
    abortWithError();
  }
#ifdef LAPTOP
  srand(time(NULL));
#endif

while(1){

  addToBin((rand() % 100));
#ifdef LAPTOP
  printHisto();
#endif
  __NV_totalSamples++;
  sortBinsByFrequency();
#ifdef LAPTOP
  fprintf(stderr,"sorted:\n");
  printHisto();
#endif
      checkInvariants();

  }

}
